import { IdeogramGenerateRequest, IdeogramGenerateResult, IdeogramGenerateResponse } from '../models/services/generate_image.model';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Ideogram Image Generation Service
 * Handles communication with Ideogram API for image generation
 */
export class IdeogramImageGeneratorService {
  private readonly baseUrl: string = 'https://api.ideogram.ai/v1/ideogram-v3/generate';

  constructor() {
    // Don't check API key in constructor - check it when service is actually used
  }

  private getApiKey(): string {
    const apiKey = process.env.IDEOGRAM_API_KEY;
    if (!apiKey || apiKey === 'your_ideogram_api_key_here') {
      throw new Error('IDEOGRAM_API_KEY environment variable is required. Please add your actual API key to .local.env');
    }
    return apiKey;
  }

  /**
   * Generate an image using Ideogram API
   * @param request - The image generation request
   * @returns Promise with generation result
   */
  async generateImage(request: IdeogramGenerateRequest): Promise<IdeogramGenerateResult> {
    const startTime = Date.now();
    
    try {
      console.log('üé® Ideogram Service: Starting image generation...');
      console.log('üìù Prompt:', request.prompt.substring(0, 100) + '...');

      // Create form data for multipart/form-data request
      const formData = new FormData();
      formData.append('prompt', request.prompt);
      
      // Add optional parameters if provided
      if (request.resolution) {
        formData.append('resolution', request.resolution);
      }
      if (request.rendering_speed) {
        formData.append('rendering_speed', request.rendering_speed);
      }
      // Set style_type to REALISTIC for photorealistic images (unless explicitly overridden)
      const styleType = request.style_type || 'REALISTIC';
      formData.append('style_type', styleType);
      if (request.num_images) {
        formData.append('num_images', request.num_images.toString());
      }
      if (request.aspect_ratio) {
        formData.append('aspect_ratio', request.aspect_ratio);
      }

      // Make API request to Ideogram
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Api-Key': this.getApiKey()
        },
        body: formData
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Ideogram API Error:', response.status, errorText);
        return {
          success: false,
          error: `Ideogram API error: ${response.status} - ${errorText}`,
          processing_time: Date.now() - startTime
        };
      }

      // Parse response
      const responseData = await response.json() as IdeogramGenerateResponse;
      
      if (!responseData.data || responseData.data.length === 0) {
        return {
          success: false,
          error: 'No images generated by Ideogram API',
          processing_time: Date.now() - startTime
        };
      }

      // Extract first image (we're generating single images for now)
      const imageData = responseData.data[0];

      console.log('‚úÖ Ideogram Service: Image generated successfully');
      console.log('üñºÔ∏è Image URL:', imageData.url);
      console.log('üìè Resolution:', imageData.resolution);
      console.log('üé≤ Seed:', imageData.seed);

      return {
        success: true,
        data: {
          imageUrl: imageData.url,
          resolution: imageData.resolution,
          seed: imageData.seed,
          created: responseData.created,
          is_image_safe: imageData.is_image_safe,
          style_type: imageData.style_type
        },
        processing_time: Date.now() - startTime
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.error('‚ùå Ideogram Service Error:', errorMessage);
      
      return {
        success: false,
        error: `Ideogram service error: ${errorMessage}`,
        processing_time: Date.now() - startTime
      };
    }
  }

  /**
   * Download and save an image from URL to the featured images folder
   * @param imageUrl - The URL of the image to download
   * @param keyword - The keyword for filename generation
   * @returns Promise with the saved image path
   */
  async downloadAndSaveImage(imageUrl: string, keyword: string): Promise<string> {
    try {
      const sanitizedKeyword = keyword
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '_')
        .trim();

      const featuredDir = path.join(__dirname, '..', '..', 'src', 'repositories', 'images', 'featured');
      if (!fs.existsSync(featuredDir)) {
        fs.mkdirSync(featuredDir, { recursive: true });
      }

      const imageResp = await fetch(imageUrl, {
        headers: {
          'Accept': 'image/*, */*;q=0.8',
          'User-Agent': 'image-downloader/1.0'
        }
      });

      if (!imageResp.ok) {
        let bodyText = '';
        try { bodyText = await imageResp.text(); } catch {}
        throw new Error(`Failed to download image. HTTP ${imageResp.status} ${bodyText?.slice(0, 200)}`);
      }

      const arrBuf = await imageResp.arrayBuffer();
      const buf = Buffer.from(arrBuf);
      const imgPath = path.join(featuredDir, `${sanitizedKeyword}_feat_image.png`);
      fs.writeFileSync(imgPath, buf);
      
      console.log('üñºÔ∏è Image saved to:', imgPath);
      return imgPath;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.warn('‚ö†Ô∏è Error downloading image:', errorMessage);
      throw new Error(`Failed to download and save image: ${errorMessage}`);
    }
  }
}

// Export singleton instance
export const ideogramImageGeneratorService = new IdeogramImageGeneratorService();
